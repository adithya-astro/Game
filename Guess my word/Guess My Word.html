<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>secredle</title>
    <style>
        :root {
            --key-bg: #d3d6da;
            --key-color: #1a1a1b;
            --absent-bg: #787c7e;
            --present-bg: #c9b458;
            --correct-bg: #6aaa64;
            --tile-border-light: #d3d6da;
            --tile-border-dark: #878a8c;
            --tile-text: #ffffff;
            --tile-red-bg: #f2b4b4; /* Red for empty tiles */
            --tile-red-border: #e09898;
            --font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }

        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        body {
            font-family: var(--font-family);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            background-color: #ffffff;
            color: var(--key-color);
            padding: 0 8px;
            box-sizing: border-box;
            overflow-y: auto; /* Allow scrolling on small height screens */
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Changed from center */
            height: 100%;
            max-width: 500px;
            width: 100%;
        }
        
        header {
            width: 100%;
            display: grid;
            grid-template-columns: 1fr 2fr 1fr; /* Left, Center, Right */
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid var(--tile-border-light);
            margin-bottom: 16px;
        }

        #header-icons-left {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            gap: 12px; /* Space between icons */
        }

        h1 {
            font-size: clamp(1.5rem, 5vw, 2.2rem); /* Responsive font size */
            font-weight: 700;
            margin: 0;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            text-align: center; /* Center the title */
            grid-column: 2; /* Place title in the center column */
        }
        
        #header-icons-right {
            display: flex;
            justify-content: flex-end; /* Align to the right */
            align-items: center;
            gap: 12px;
            grid-column: 3; /* Place settings in the right column */
        }

        .header-icon {
            width: 24px;
            height: 24px;
            cursor: pointer;
            fill: var(--tile-border-dark);
            transition: transform 0.3s ease;
        }
        .header-icon:hover {
            transform: scale(1.1) rotate(15deg);
        }
        #settings-icon:hover {
            transform: rotate(60deg);
        }


        #grid-container {
            display: grid;
            grid-template-rows: repeat(5, 1fr); /* 5 rows */
            grid-gap: 5px;
            width: 100%;
            max-width: 300px; /* Max width for 5 tiles */
            margin: 0 auto;
            flex-shrink: 0;
        }

        .row {
            display: grid;
            grid-template-columns: repeat(5, 1fr); /* 5 letters */
            grid-gap: 5px;
        }

        .tile {
            width: 100%;
            height: 100%;
            border: 2px solid var(--tile-red-border); /* Red border first */
            background-color: var(--tile-red-bg); /* Red background first */
            display: inline-flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(1.5rem, 5vw, 2.5rem); /* Responsive font size */
            font-weight: bold;
            text-transform: uppercase;
            box-sizing: border-box;
            transition: transform 0.2s, background-color 0.2s, border-color 0.2s;
            color: var(--key-color);
            aspect-ratio: 1 / 1; /* Keep tiles square */
        }

        .tile.filled {
            border-color: var(--tile-border-dark);
            background-color: #fff; /* White when typed */
            animation: popIn 0.1s;
        }
        
        .tile.shake { animation: shake 0.5s; }
        /* Replaced flip with a reveal/flash effect */
        .tile.reveal { animation: reveal 0.6s ease forwards; }

        @keyframes popIn {
            from { transform: scale(0.8); opacity: 0; }
            40% { transform: scale(1.1); opacity: 1; }
            to { transform: scale(1); }
        }
        
        @keyframes shake {
            10%, 90% { transform: translateX(-1px); }
            20%, 80% { transform: translateX(2px); }
            30%, 50%, 70% { transform: translateX(-4px); }
            40%, 60% { transform: translateX(4px); }
        }
        
        @keyframes reveal {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        #keyboard {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px 0 8px 0;
            width: 100%;
        }

        .key-row {
            display: flex;
            justify-content: center;
            width: 100%;
            margin: 4px 0;
        }

        .key {
            font-family: var(--font-family);
            font-size: 1rem;
            font-weight: bold;
            padding: 0;
            margin: 0 2px; /* Adjusted margin */
            height: 58px;
            border-radius: 4px;
            cursor: pointer;
            border: none;
            background-color: var(--key-bg);
            color: var(--key-color);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-grow: 1;
            flex-basis: 0; /* Helps with flex distribution */
            text-transform: uppercase;
            -webkit-tap-highlight-color: rgba(0,0,0,0.3);
        }
        
        .key.wide { flex-grow: 1.5; font-size: 0.8rem; }

        /* Color classes for tiles and keys */
        .correct, .key.correct {
            background-color: var(--correct-bg) !important;
            border-color: var(--correct-bg) !important;
            color: var(--tile-text);
        }

        .present, .key.present {
            background-color: var(--present-bg) !important;
            border-color: var(--present-bg) !important;
            color: var(--tile-text);
        }

        .absent, .key.absent {
            background-color: var(--absent-bg) !important;
            border-color: var(--absent-bg) !important;
            color: var(--tile-text);
        }
        
        #message-box {
            position: fixed;
            top: 10%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease, top 0.3s ease;
            z-index: 1000;
        }

        /* --- Modal Styles --- */
        #modal-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 1;
            transition: opacity 0.2s ease, visibility 0.2s ease;
        }

        #modal-container.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        #modal {
            background-color: white;
            padding: 24px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            width: 90%;
            max-width: 400px; /* Wider for more content */
            text-align: left;
            position: relative;
        }

        .modal-close-btn {
            position: absolute;
            top: 10px;
            right: 14px;
            font-size: 2rem;
            font-weight: bold;
            color: var(--key-bg);
            cursor: pointer;
            line-height: 1;
        }
        .modal-close-btn:hover {
            color: var(--absent-bg);
        }

        #modal-title {
            margin-top: 0;
            margin-bottom: 16px;
            font-size: 1.5rem;
            text-align: center;
        }
        
        /* Scrollable content area */
        .modal-content {
            max-height: 60vh; /* Limit height */
            overflow-y: auto; /* Add scrollbar if needed */
            padding-right: 10px; /* Space for scrollbar */
        }

        .modal-content h3 {
            font-size: 1.2rem;
            margin-top: 20px;
            margin-bottom: 10px;
            border-bottom: 1px solid var(--tile-border-light);
            padding-bottom: 5px;
        }
        
        .modal-content p, .modal-content li {
            font-size: 1rem;
            line-height: 1.5;
            color: var(--absent-bg);
        }
        
        .modal-content strong {
            color: var(--key-color);
        }
        
        /* For inputs/buttons inside modals */
        #modal-input {
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            border: 1px solid var(--tile-border-light);
            border-radius: 4px;
            font-size: 1.2rem;
            text-align: center;
            margin-bottom: 20px;
            letter-spacing: 0.2em;
            text-transform: uppercase;
        }

        #modal-buttons {
            display: flex;
            justify-content: space-around;
            gap: 10px;
            margin-top: 20px;
        }

        #modal-buttons button {
            flex-grow: 1;
            padding: 10px;
            border: none;
            border-radius: 4px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
        }

        #modal-submit-btn, #share-btn {
            background-color: var(--correct-bg);
            color: white;
        }
        #modal-cancel-btn {
            background-color: var(--key-bg);
            color: var(--key-color);
        }
        
        /* Specific for Win Modal */
        #win-grid-share {
            font-family: monospace;
            font-size: 1.2rem;
            line-height: 1.2;
            text-align: center;
            white-space: pre-wrap;
            margin: 15px 0;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 4px;
        }
        
        /* Style for example tiles in Help */
        .example-tile-row {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }
        .example-tile {
            width: 40px;
            height: 40px;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: bold;
            border: 2px solid;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div id="message-box"></div>
    
    <div id="game-container">
        <header>
            <div id="header-icons-left">
                <svg id="info-icon" class="header-icon" xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24"><path d="M0 0h24v24H0z" fill="none"/><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/></svg>

                <svg id="help-icon" class="header-icon" xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24"><path d="M0 0h24v24H0z" fill="none"/><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"/></svg>
            </div>
            
            <h1>GUESS MY WORD</h1>
            
            <div id="header-icons-right">
                <svg id="settings-icon" class="header-icon" xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24"><path d="M0 0h24v24H0z" fill="none"/><path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"/></svg>
            </div>
        </header>
        
        <div id="grid-container"></div>
        
        <div id="keyboard"></div>
    </div>

    <div id="modal-container" class="hidden">
        <div id="modal">
            <span class="modal-close-btn">&times;</span>
            <h2 id="modal-title">Modal Title</h2>
            
            <div id="modal-content-area" class="modal-content">
                </div>
            
            <div id="modal-buttons">
                </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const gridContainer = document.getElementById('grid-container');
            const keyboardContainer = document.getElementById('keyboard');
            const messageBox = document.getElementById('message-box');
            
            // Header Icons
            const settingsIcon = document.getElementById('settings-icon');
            const helpIcon = document.getElementById('help-icon');
            const infoIcon = document.getElementById('info-icon');

            // Modal Elements
            const modalContainer = document.getElementById('modal-container');
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalContentArea = document.getElementById('modal-content-area');
            const modalButtons = document.getElementById('modal-buttons');
            const modalCloseBtn = document.querySelector('.modal-close-btn');

            // --- Game State ---
            const defaultWord = "HELLO";
            const secretPin = "1234";
            const guessRows = 5; // 5 guesses
            const wordLength = 5; // 5 letters
            const saveKey = 'guessMyWord_gameState';
            
            let targetWord = defaultWord;
            let currentRow = 0;
            let currentTile = 0;
            let isGameOver = false;
            let grid = []; // 2D array for tile elements
            let keyboardState = {};
            let modalState = {
                isOpen: false,
                resolve: null
            };

            // --- 1. INITIALIZATION ---

            function initGame() {
                // Determine the target word
                targetWord = getWordFromURL() || loadGameState()?.targetWord || defaultWord;
                targetWord = targetWord.toUpperCase();

                // Clear any old saved game if the word is different
                const savedState = loadGameState();
                if (savedState && savedState.targetWord !== targetWord) {
                    localStorage.removeItem(saveKey);
                    // Reset all state variables
                    currentRow = 0;
                    currentTile = 0;
                    isGameOver = false;
                    keyboardState = {};
                }
                
                // Reset modal state
                modalState.isOpen = false;
                
                buildGrid();
                buildKeyboard();
                
                // Try to load the game
                try {
                    if (savedState && savedState.targetWord === targetWord) {
                        restoreGameState(savedState);
                    }
                } catch (error) {
                    console.error("Failed to restore game state:", error);
                    localStorage.removeItem(saveKey);
                    // Reset grid/keyboard if restore fails
                    buildGrid();
                    buildKeyboard();
                }

                // Check if the loaded game was already over
                if (isGameOver) {
                    if (savedState.guesses[currentRow - 1] === targetWord) {
                        // Won
                        showWinModal(savedState.guesses);
                    } else {
                        // Lost
                        showMessage(`Game Over! The word was ${targetWord}`, 5000);
                    }
                }
            }
            
            function getWordFromURL() {
                const params = new URLSearchParams(window.location.search);
                const encodedWord = params.get('word');
                if (encodedWord) {
                    try {
                        const decodedWord = atob(encodedWord);
                        if (decodedWord.length === wordLength) {
                            return decodedWord.toUpperCase();
                        }
                    } catch (e) {
                        console.error("Failed to decode word from URL:", e);
                    }
                }
                return null;
            }

            function buildGrid() {
                gridContainer.innerHTML = '';
                grid = [];
                for (let i = 0; i < guessRows; i++) {
                    const rowElement = document.createElement('div');
                    rowElement.classList.add('row');
                    grid[i] = [];
                    for (let j = 0; j < wordLength; j++) {
                        const tileElement = document.createElement('div');
                        tileElement.classList.add('tile');
                        rowElement.appendChild(tileElement);
                        grid[i][j] = tileElement;
                    }
                    gridContainer.appendChild(rowElement);
                }
            }

            function buildKeyboard() {
                keyboardContainer.innerHTML = '';
                const keys = [
                    "Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P",
                    "A", "S", "D", "F", "G", "H", "J", "K", "L",
                    "ENTER", "Z", "X", "C", "V", "B", "N", "M", "BACKSPACE"
                ];
                const keyLayout = [keys.slice(0, 10), keys.slice(10, 19), keys.slice(19)];
                keyLayout.forEach(row => {
                    const rowDiv = document.createElement('div');
                    rowDiv.classList.add('key-row');
                    row.forEach(key => {
                        const keyButton = document.createElement('button');
                        keyButton.textContent = key === "BACKSPACE" ? "⌫" : key;
                        keyButton.classList.add('key');
                        keyButton.setAttribute('data-key', key);
                        if (key.length > 1) keyButton.classList.add('wide');
                        keyButton.addEventListener('click', () => handleInteraction(key));
                        rowDiv.appendChild(keyButton);
                    });
                    keyboardContainer.appendChild(rowDiv);
                });
            }

            // --- 2. GAME STATE MANAGEMENT (SAVE/LOAD) ---
            
            function saveGameState(guesses) {
                const state = {
                    targetWord: targetWord,
                    guesses: guesses,
                    currentRow: currentRow,
                    isGameOver: isGameOver,
                    keyboardState: keyboardState
                };
                localStorage.setItem(saveKey, JSON.stringify(state));
            }

            function loadGameState() {
                const stateString = localStorage.getItem(saveKey);
                if (stateString) {
                    return JSON.parse(stateString);
                }
                return null;
            }

            function restoreGameState(state) {
                // Restore grid
                state.guesses.forEach((guess, rowIndex) => {
                    const guessLetters = guess.split('');
                    const [states] = checkGuess(guess, targetWord); // Get tile states
                    
                    guessLetters.forEach((letter, tileIndex) => {
                        const tile = grid[rowIndex][tileIndex];
                        tile.textContent = letter;
                        tile.classList.add('filled');
                        tile.classList.add(states[tileIndex]); // Add correct/present/absent
                    });
                });

                // Restore keyboard
                keyboardState = state.keyboardState || {};
                for (const [letter, state] of Object.entries(keyboardState)) {
                    updateKeyColor(letter, state, true); // Force update
                }

                // Restore game progress
                currentRow = state.currentRow;
                isGameOver = state.isGameOver;
            }

            // --- 3. EVENT LISTENERS ---

            // Physical Keyboard
            document.addEventListener('keydown', (e) => handleInteraction(e.key));
            
            // On-screen Keyboard (already added in buildKeyboard)

            // Modal Listeners
            modalCloseBtn.addEventListener('click', hideModal);
            modalContainer.addEventListener('click', (e) => {
                if (e.target === modalContainer) {
                    hideModal();
                }
            });

            // Header Icon Listeners
            helpIcon.addEventListener('click', showHelpModal);
            infoIcon.addEventListener('click', showAboutModal);
            settingsIcon.addEventListener('click', showSettingsModal);

            // --- 4. MODAL/MESSAGE UI ---

            const showMessage = (message, duration = 1500) => {
                messageBox.textContent = message;
                messageBox.style.visibility = 'visible';
                messageBox.style.opacity = '1';
                messageBox.style.top = '12%';

                setTimeout(() => {
                    messageBox.style.opacity = '0';
                    messageBox.style.visibility = 'hidden';
                    messageBox.style.top = '10%';
                }, duration);
            };

            function showModal(title, contentHtml, buttonsHtml = '') {
                modalTitle.textContent = title;
                modalContentArea.innerHTML = contentHtml;
                modalButtons.innerHTML = buttonsHtml;
                modalContainer.classList.remove('hidden');
                modalState.isOpen = true;

                // Add listeners to any new buttons
                modalButtons.querySelectorAll('button').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        if (modalState.resolve) {
                            modalState.resolve(e.target.dataset.value || null);
                            modalState.resolve = null;
                        }
                    });
                });
            }

            function hideModal() {
                modalContainer.classList.add('hidden');
                modalState.isOpen = false;
                if (modalState.resolve) {
                    modalState.resolve(null); // Resolve with null if cancelled
                    modalState.resolve = null;
                }
            }

            function showModalWithInput(config) {
                const content = `
                    <input type="${config.inputType || 'text'}" id="modal-input" 
                           autocomplete="off" 
                           maxlength="${config.maxLength || 524288}" 
                           placeholder="${config.placeholder || ''}"
                    />
                `;
                const buttons = `
                    <button id="modal-cancel-btn" data-value="cancel">Cancel</button>
                    <button id="modal-submit-btn" data-value="submit">Submit</button>
                `;
                showModal(config.title, content, buttons);
                
                const input = document.getElementById('modal-input');
                input.focus();

                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        document.getElementById('modal-submit-btn').click();
                    } else if (e.key === 'Escape') {
                        document.getElementById('modal-cancel-btn').click();
                    }
                });

                return new Promise((resolve) => {
                    modalState.resolve = (value) => {
                        if (value === 'submit') {
                            resolve(input.value);
                        } else {
                            resolve(null); // Cancelled
                        }
                        hideModal();
                    };
                });
            }
            
            function showHelpModal() {
                const content = `
                    <h3>How to Play</h3>
                    <p>Guess the <strong>5-letter word</strong> in 5 tries.</p>
                    <ul>
                        <li>Each guess must be a valid 5-letter word. Hit ENTER to submit.</li>
                        <li>After each guess, the color of the tiles will change to show how close your guess was to the word.</li>
                    </ul>
                    <div class="example-tile-row">
                        <div class="example-tile correct" style="color:white; border-color:var(--correct-bg);">W</div>
                        <div class="example-tile" style="border-color:var(--tile-border-light);">E</div>
                        <div class="example-tile" style="border-color:var(--tile-border-light);">A</div>
                        <div class="example-tile" style="border-color:var(--tile-border-light);">R</div>
                        <div class="example-tile" style="border-color:var(--tile-border-light);">Y</div>
                    </div>
                    <p><strong>W</strong> is in the word and in the correct spot.</p>
                    
                    <div class="example-tile-row">
                        <div class="example-tile" style="border-color:var(--tile-border-light);">P</div>
                        <div class="example-tile present" style="color:white; border-color:var(--present-bg);">I</div>
                        <div class="example-tile" style="border-color:var(--tile-border-light);">L</div>
                        <div class="example-tile" style="border-color:var(--tile-border-light);">L</div>
                        <div class="example-tile" style="border-color:var(--tile-border-light);">S</div>
                    </div>
                    <p><strong>I</strong> is in the word but in the wrong spot.</p>
                    
                    <div class="example-tile-row">
                        <div class="example-tile" style="border-color:var(--tile-border-light);">V</div>
                        <div class="example-tile" style="border-color:var(--tile-border-light);">A</div>
                        <div class="example-tile" style="border-color:var(--tile-border-light);">G</div>
                        <div class="example-tile absent" style="color:white; border-color:var(--absent-bg);">U</div>
                        <div class="example-tile" style="border-color:var(--tile-border-light);">E</div>
                    </div>
                    <p><strong>U</strong> is not in the word in any spot.</p>

                    <h3>How to Set a Word</h3>
                    <ol>
                        <li>Click the <strong>Settings icon (⚙️)</strong> in the header.</li>
                        <li>Enter the secret PIN: <strong>${secretPin}</strong></li>
                        <li>Type your new 5-letter word and submit.</li>
                        <li>A new shareable link will be generated for you to send to a friend!</li>
                    </ol>
                `;
                showModal("How to Play", content, '');
            }
            
            function showAboutModal() {
                const content = `
                    <p>This is a fun project inspired by the game <strong>Wordle</strong>.</p>
                    <p>It was created with the help of AI tools like <strong>Google Gemini</strong> to explore web development and game logic.</p>
                    <p>This game is not for commercial use.</p>
                    <p>I created this game for my girlfriend. We both enjoy challenging each other with word games like Wordle and Duotrigordle, so I wanted to design something personal — a game where I could set custom words for her to guess. That’s how this project came to life — a fun, interactive way for us to keep our word battles going! </p>
                `;
                showModal("About This Project", content, '');
            }

            async function showSettingsModal() {
                const pinAttempt = await showModalWithInput({
                    title: 'Enter Secret PIN',
                    inputType: 'password',
                    maxLength: 4,
                    placeholder: '1234'
                });

                if (pinAttempt === secretPin) {
                    const newWordAttempt = await showModalWithInput({
                        title: 'Enter a new 5-letter word',
                        inputType: 'text',
                        maxLength: 5,
                    });

                    if (newWordAttempt && newWordAttempt.length === 5) {
                        const newWord = newWordAttempt.toUpperCase();
                        const encodedWord = btoa(newWord); // Encode the word
                        const newUrl = `${window.location.origin}${window.location.pathname}?word=${encodedWord}`;
                        
                        // Use the new share function
                        await shareOrCopy({
                            title: 'Guess My Word!',
                            text: 'I have a secret word for you to guess. Click the link to play:',
                            url: newUrl
                        });
                        
                        // Set this new word for the current player too
                        targetWord = newWord;
                        resetGame();
                        
                    } else if (newWordAttempt !== null) {
                        showMessage("Invalid word. Must be 5 letters.", 2000);
                    }
                } else if (pinAttempt !== null) {
                    showMessage("Incorrect PIN.", 2000);
                }
            }
            
            function showWinModal(guesses) {
                const guessCount = currentRow; // currentRow is 1-based after win
                const emojiGrid = generateEmojiGrid(guesses);
                const shareText = `I found the word ${targetWord} in ${guessCount}/${guessRows} guesses!\n\n${emojiGrid}`;

                const content = `
                    <p>You found the word <strong>${targetWord}</strong> in ${guessCount} ${guessCount > 1 ? "guesses" : "guess"}!</p>
                    <div id="win-grid-share">${emojiGrid}</div>
                `;
                const buttons = `
                    <button id="share-btn">Share</button>
                `;
                showModal("You Won!", content, buttons);
                
                document.getElementById('share-btn').addEventListener('click', () => {
                    shareOrCopy({
                        title: 'My Guess My Word Result',
                        text: shareText
                    });
                });
            }

            // --- 5. GAME LOGIC ---

            function handleInteraction(key) {
                if (isGameOver || modalState.isOpen) return;
                
                const upperKey = key.toUpperCase();
                
                if (upperKey === 'ENTER') {
                    submitGuess();
                } else if (upperKey === 'BACKSPACE' || upperKey === '⌫') {
                    deleteLetter();
                } else if (upperKey.length === 1 && upperKey >= 'A' && upperKey <= 'Z') {
                    addLetter(upperKey);
                }
            }

            const addLetter = (letter) => {
                if (currentTile < wordLength && currentRow < guessRows) {
                    const tile = grid[currentRow][currentTile];
                    tile.textContent = letter;
                    tile.classList.add('filled');
                    currentTile++;
                }
            };
            
            const deleteLetter = () => {
                if (currentTile > 0) {
                    currentTile--;
                    const tile = grid[currentRow][currentTile];
                    tile.textContent = '';
                    tile.classList.remove('filled');
                }
            };
            
            const submitGuess = () => {
                if (currentTile !== wordLength) {
                    shakeRow();
                    showMessage("Not enough letters");
                    return;
                }
                
                const guess = grid[currentRow].map(tile => tile.textContent).join('');
                
                // TODO: Add dictionary check here if desired
                // if (!isValidWord(guess)) {
                //     shakeRow();
                //     showMessage("Not in word list");
                //     return;
                // }
                
                revealGuess(guess);
            };
            
            const shakeRow = () => {
                const rowTiles = grid[currentRow];
                rowTiles.forEach(tile => tile.classList.add('shake'));
                setTimeout(() => {
                    rowTiles.forEach(tile => tile.classList.remove('shake'));
                }, 500);
            };

            const revealGuess = (guess) => {
                const tiles = grid[currentRow];
                const [states, newKeyboardState] = checkGuess(guess, targetWord);
                
                // Update keyboard state object
                Object.assign(keyboardState, newKeyboardState);

                tiles.forEach((tile, index) => {
                    setTimeout(() => {
                        tile.classList.add('reveal'); // Use new reveal animation
                        tile.classList.add(states[index]);
                        updateKeyColor(tile.textContent, states[index]);
                    }, index * 200); // Faster reveal
                });

                // Wait for animation to finish before checking win/loss
                setTimeout(() => {
                    checkWinLoss(guess);
                }, wordLength * 200 + 100);
            };
            
            function checkGuess(guess, target) {
                let tileStates = new Array(wordLength).fill('absent');
                let keyStates = {};
                let targetLetters = target.split('');

                // 1st pass: Check for 'correct' (green)
                for (let i = 0; i < wordLength; i++) {
                    if (guess[i] === target[i]) {
                        tileStates[i] = 'correct';
                        keyStates[guess[i]] = 'correct';
                        targetLetters[i] = null; // Mark as used
                    }
                }

                // 2nd pass: Check for 'present' (yellow)
                for (let i = 0; i < wordLength; i++) {
                    if (tileStates[i] === 'correct') continue; // Already handled

                    if (targetLetters.includes(guess[i])) {
                        tileStates[i] = 'present';
                        
                        // Only update key if not already correct
                        if (keyStates[guess[i]] !== 'correct') {
                            keyStates[guess[i]] = 'present';
                        }
                        
                        // Mark as used
                        targetLetters[targetLetters.indexOf(guess[i])] = null;
                    }
                }
                
                // 3rd pass: 'absent' (grey)
                for (let i = 0; i < wordLength; i++) {
                    if (tileStates[i] !== 'correct' && tileStates[i] !== 'present') {
                        // Only update key if not already correct or present
                        if (!keyStates[guess[i]]) {
                             keyStates[guess[i]] = 'absent';
                        }
                    }
                }
                
                return [tileStates, keyStates];
            }


            const updateKeyColor = (letter, state, force = false) => {
                const key = keyboardContainer.querySelector(`[data-key="${letter.toUpperCase()}"]`);
                if (!key) return;

                if (!force) {
                    const currentStatus = keyboardState[letter];
                    // Don't downgrade from correct, or from present (unless new is correct)
                    if (currentStatus === 'correct' || (currentStatus === 'present' && state !== 'correct')) {
                        return;
                    }
                }
                
                // Remove all state classes before adding the new one
                key.classList.remove('correct', 'present', 'absent');
                key.classList.add(state);
            };

            const checkWinLoss = (guess) => {
                const allGuesses = grid.slice(0, currentRow + 1).map(row => 
                    row.map(tile => tile.textContent).join('')
                );
                
                if (guess === targetWord) {
                    isGameOver = true;
                    currentRow++; // Increment to show correct count
                    saveGameState(allGuesses);
                    setTimeout(() => showWinModal(allGuesses), 500);
                    return;
                }

                currentRow++;
                currentTile = 0;
                
                if (currentRow >= guessRows) {
                    isGameOver = true;
                    showMessage(`Game Over! The word was ${targetWord}`, 5000);
                    saveGameState(allGuesses);
                } else {
                    // Only save if game is not over
                    saveGameState(allGuesses);
                }
            };
            
            function resetGame() {
                // Reset state variables
                currentRow = 0;
                currentTile = 0;
                isGameOver = false;
                keyboardState = {};
                
                // Clear saved data for this word
                localStorage.removeItem(saveKey);
                
                // Re-build UI
                buildGrid();
                buildKeyboard();
            }
            
            // --- 6. UTILITY FUNCTIONS ---

            function generateEmojiGrid(guesses) {
                const emojiMap = { 'correct': '🟩', 'present': '🟨', 'absent': '⬛' };
                let gridString = '';

                for (let i = 0; i < currentRow; i++) {
                    const guess = guesses[i] || '';
                    const [states] = checkGuess(guess, targetWord);
                    gridString += states.map(state => emojiMap[state] || '⬛').join('');
                    if (i < currentRow - 1) {
                        gridString += '\n';
                    }
                }
                return gridString;
            }

            async function shareOrCopy(shareData) {
                const textToCopy = shareData.url ? `${shareData.text}\n${shareData.url}` : shareData.text;

                // Use Web Share API if available
                if (navigator.share) {
                    try {
                        await navigator.share(shareData);
                        // No message needed here as the share UI provides feedback
                    } catch (err) {
                        // This can happen if the user cancels the share dialog
                        console.log("Share was cancelled or failed:", err);
                    }
                } else {
                    // Fallback to clipboard
                    copyToClipboard(textToCopy);
                    showMessage("Copied to clipboard!", 2000);
                }
            }

            function copyToClipboard(text) {
                // Use new clipboard API if available
                if (navigator.clipboard && window.isSecureContext) {
                    navigator.clipboard.writeText(text).catch(err => {
                        console.warn("Clipboard API failed, falling back...", err);
                        fallbackCopyTextToClipboard(text);
                    });
                } else {
                    // Fallback for http or older browsers
                    fallbackCopyTextToClipboard(text);
                }
            }

            function fallbackCopyTextToClipboard(text) {
                const textArea = document.createElement("textarea");
                textArea.value = text;
                
                // Avoid scrolling to bottom
                textArea.style.top = "0";
                textArea.style.left = "0";
                textArea.style.position = "fixed";

                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();

                try {
                    document.execCommand('copy');
                } catch (err) {
                    console.error('Fallback: Oops, unable to copy', err);
                }

                document.body.removeChild(textArea);
            }

            // --- START GAME ---
            initGame();
        });
    </script>
</body>
</html>

